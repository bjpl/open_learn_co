"""Excel export formatter"""

from typing import List, Dict, Any, Optional
import pandas as pd
from datetime import datetime
import json
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.utils.dataframe import dataframe_to_rows
from .base import BaseExporter


class ExcelExporter(BaseExporter):
    """Export data to Excel (.xlsx) format"""

    def __init__(self, export_dir: str = "exports"):
        super().__init__(export_dir)
        self.max_rows = 100000

    def get_file_extension(self) -> str:
        return "xlsx"

    async def export(
        self,
        data: List[Dict[str, Any]],
        filename: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """
        Export data to Excel file with formatting

        Args:
            data: List of records to export
            filename: Base filename
            metadata: Optional metadata for summary sheet

        Returns:
            Path to exported Excel file
        """
        # Sanitize data
        clean_data = self.sanitize_data(data)

        # Limit rows
        if len(clean_data) > self.max_rows:
            clean_data = clean_data[:self.max_rows]

        # Convert to DataFrame
        df = pd.DataFrame(clean_data)
        df = self._flatten_dataframe(df)

        # Generate filename and path
        full_filename = self.generate_filename(filename)
        file_path = self.get_file_path(full_filename)

        # Create Excel workbook with multiple sheets
        with pd.ExcelWriter(str(file_path), engine='openpyxl') as writer:
            # Write main data sheet
            df.to_excel(writer, sheet_name='Data', index=False)

            # Write summary sheet
            self._create_summary_sheet(writer, df, metadata or {})

            # Write metadata sheet
            self._create_metadata_sheet(writer, metadata or {})

            # Format data sheet
            workbook = writer.book
            self._format_data_sheet(workbook['Data'], df)

        return str(file_path)

    def _flatten_dataframe(self, df: pd.DataFrame) -> pd.DataFrame:
        """Flatten nested structures in DataFrame"""
        for col in df.columns:
            if df[col].dtype == object:
                sample = df[col].iloc[0] if len(df) > 0 else None

                if isinstance(sample, (list, dict)):
                    # Convert to JSON string
                    df[col] = df[col].apply(
                        lambda x: json.dumps(x, ensure_ascii=False) if x else ""
                    )
                elif isinstance(sample, datetime):
                    # Keep as datetime for Excel formatting
                    pass

        return df

    def _create_summary_sheet(
        self,
        writer: pd.ExcelWriter,
        df: pd.DataFrame,
        metadata: Dict[str, Any]
    ):
        """Create summary statistics sheet"""
        summary_data = {
            'Metric': [
                'Total Records',
                'Total Columns',
                'Export Date',
                'File Format'
            ],
            'Value': [
                len(df),
                len(df.columns),
                datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'Excel (.xlsx)'
            ]
        }

        # Add numeric column statistics
        numeric_cols = df.select_dtypes(include=['number']).columns
        for col in numeric_cols[:5]:  # Limit to first 5 numeric columns
            summary_data['Metric'].extend([
                f'{col} - Mean',
                f'{col} - Min',
                f'{col} - Max'
            ])
            summary_data['Value'].extend([
                f"{df[col].mean():.2f}" if not df[col].isna().all() else "N/A",
                f"{df[col].min():.2f}" if not df[col].isna().all() else "N/A",
                f"{df[col].max():.2f}" if not df[col].isna().all() else "N/A"
            ])

        summary_df = pd.DataFrame(summary_data)
        summary_df.to_excel(writer, sheet_name='Summary', index=False)

        # Format summary sheet
        workbook = writer.book
        self._format_summary_sheet(workbook['Summary'])

    def _create_metadata_sheet(
        self,
        writer: pd.ExcelWriter,
        metadata: Dict[str, Any]
    ):
        """Create metadata information sheet"""
        metadata_data = {
            'Key': ['Export Version', 'Generated By'],
            'Value': ['1.0', 'OpenLearn Colombia Platform']
        }

        # Add custom metadata
        for key, value in metadata.items():
            metadata_data['Key'].append(str(key))
            metadata_data['Value'].append(str(value))

        metadata_df = pd.DataFrame(metadata_data)
        metadata_df.to_excel(writer, sheet_name='Metadata', index=False)

    def _format_data_sheet(self, worksheet, df: pd.DataFrame):
        """Apply formatting to data sheet"""
        # Header styling
        header_fill = PatternFill(start_color="1a237e", end_color="1a237e", fill_type="solid")
        header_font = Font(bold=True, color="FFFFFF", size=12)
        header_alignment = Alignment(horizontal="center", vertical="center")

        # Apply header formatting
        for cell in worksheet[1]:
            cell.fill = header_fill
            cell.font = header_font
            cell.alignment = header_alignment

        # Freeze header row
        worksheet.freeze_panes = "A2"

        # Auto-size columns
        for column in worksheet.columns:
            max_length = 0
            column_letter = column[0].column_letter

            for cell in column:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass

            adjusted_width = min(max_length + 2, 50)  # Cap at 50
            worksheet.column_dimensions[column_letter].width = adjusted_width

        # Add filters
        worksheet.auto_filter.ref = worksheet.dimensions

        # Conditional formatting for sentiment scores (if present)
        if 'sentiment_score' in df.columns:
            col_idx = df.columns.get_loc('sentiment_score') + 1  # Excel is 1-indexed
            self._apply_sentiment_formatting(worksheet, col_idx, len(df))

    def _format_summary_sheet(self, worksheet):
        """Apply formatting to summary sheet"""
        # Header styling
        header_fill = PatternFill(start_color="1a237e", end_color="1a237e", fill_type="solid")
        header_font = Font(bold=True, color="FFFFFF", size=12)

        for cell in worksheet[1]:
            cell.fill = header_fill
            cell.font = header_font

        # Auto-size columns
        for column in worksheet.columns:
            max_length = 0
            column_letter = column[0].column_letter

            for cell in column:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass

            adjusted_width = min(max_length + 2, 50)
            worksheet.column_dimensions[column_letter].width = adjusted_width

    def _apply_sentiment_formatting(self, worksheet, col_idx: int, row_count: int):
        """Apply color coding based on sentiment scores"""
        from openpyxl.styles import Color
        from openpyxl.formatting.rule import ColorScaleRule

        # Define color scale: red (negative) -> yellow (neutral) -> green (positive)
        color_scale = ColorScaleRule(
            start_type='min',
            start_color='F8696B',  # Red
            mid_type='percentile',
            mid_value=50,
            mid_color='FFEB84',    # Yellow
            end_type='max',
            end_color='63BE7B'     # Green
        )

        # Apply to sentiment score column (skip header)
        col_letter = worksheet.cell(row=1, column=col_idx).column_letter
        cell_range = f"{col_letter}2:{col_letter}{row_count + 1}"
        worksheet.conditional_formatting.add(cell_range, color_scale)

    async def export_articles(
        self,
        articles: List[Dict[str, Any]],
        filename: str = "articles"
    ) -> str:
        """
        Export articles with specific column ordering

        Args:
            articles: List of article records
            filename: Base filename

        Returns:
            Path to exported Excel file
        """
        # Define column order
        column_order = [
            'title', 'summary', 'content', 'source', 'category',
            'published_date', 'sentiment_score', 'difficulty_level', 'url'
        ]

        df = pd.DataFrame(articles)
        existing_cols = [col for col in column_order if col in df.columns]
        other_cols = [col for col in df.columns if col not in column_order]
        df = df[existing_cols + other_cols]

        df = self._flatten_dataframe(df)

        metadata = {'type': 'articles', 'record_count': len(articles)}

        return await self.export(articles, filename, metadata)
